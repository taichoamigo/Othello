<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI対戦オセロ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --board-bg: #008080; /* ティール */
            --black-piece: #1f2937; /* ダークグレー */
            --white-piece: #f9fafb; /* オフホワイト */
            --hint-color: rgba(4, 120, 87, 0.4); /* エメラルド（半透明） */
            --cell-border: #006060;
        }
        body {
            font-family: 'Noto Sans JP', sans-serif;
            touch-action: manipulation; /* ダブルタップによるズームを無効化 */
        }
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vw;
            height: 90vw;
            max-width: 500px;
            max-height: 500px;
            background-color: var(--board-bg);
            border: 2px solid var(--cell-border);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2), 0 6px 6px rgba(0,0,0,0.25);
            aspect-ratio: 1 / 1;
        }
        .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid var(--cell-border);
            cursor: pointer;
            position: relative;
        }
        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3), 0 2px 3px rgba(0,0,0,0.4);
            transition: transform 0.4s ease-in-out, background-color 0.4s ease-in-out;
        }
        .piece.black { background-color: var(--black-piece); }
        .piece.white { background-color: var(--white-piece); }
        .piece.flipped { transform: rotateY(180deg); }

        .valid-move-hint {
            width: 50%;
            height: 50%;
            border-radius: 50%;
            background-color: var(--hint-color);
            position: absolute;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(0.9); opacity: 0.7; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(0.9); opacity: 0.7; }
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-bold text-center text-gray-800 mb-4">AI対戦オセロ</h1>

        <!-- ゲーム情報パネル -->
        <div class="flex justify-between items-center bg-white p-3 rounded-lg shadow-md mb-4">
            <div class="flex items-center space-x-3">
                <div class="w-8 h-8 rounded-full bg-gray-800"></div>
                <div class="text-xl font-bold text-gray-800">あなた: <span id="black-score">2</span></div>
            </div>
            <div class="flex items-center space-x-3">
                <div class="text-xl font-bold text-gray-200">
                    <span class="text-white">AI:</span> <span id="white-score" class="text-white">2</span>
                </div>
                <div class="w-8 h-8 rounded-full bg-white border-2 border-gray-300"></div>
            </div>
        </div>

        <!-- メッセージエリア -->
        <div id="message-area" class="text-center text-lg font-semibold text-teal-700 h-8 mb-4"></div>
    </div>

    <!-- ゲーム盤 -->
    <div id="board" class="board"></div>

    <!-- ゲームコントロール -->
    <div class="mt-6">
        <button id="restart-button" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105">
            新しいゲーム
        </button>
    </div>

    <script>
        // --- DOM要素の取得 ---
        const boardElement = document.getElementById('board');
        const blackScoreElement = document.getElementById('black-score');
        const whiteScoreElement = document.getElementById('white-score');
        const messageArea = document.getElementById('message-area');
        const restartButton = document.getElementById('restart-button');

        // --- 定数とゲーム状態 ---
        const EMPTY = 0;
        const BLACK = 1; // プレイヤー
        const WHITE = 2; // コンピュータ
        const BOARD_SIZE = 8;
        const DIRECTIONS = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1], [1, 0], [1, 1]
        ];
        
        // AIの思考の深さ（大きいほど強くなるが、計算に時間がかかる）
        const AI_DEPTH = 4;

        // 各マスの戦略的な価値を評価するための重み付け
        const POSITION_WEIGHTS = [
            [120, -20, 20,  5,  5, 20, -20, 120],
            [-20, -40, -5, -5, -5, -5, -40, -20],
            [ 20,  -5, 15,  3,  3, 15,  -5,  20],
            [  5,  -5,  3,  3,  3,  3,  -5,   5],
            [  5,  -5,  3,  3,  3,  3,  -5,   5],
            [ 20,  -5, 15,  3,  3, 15,  -5,  20],
            [-20, -40, -5, -5, -5, -5, -40, -20],
            [120, -20, 20,  5,  5, 20, -20, 120]
        ];

        let board = [];
        let currentPlayer;
        let gameOver;
        let playerTurnBlocked = false; // プレイヤーの操作を一時的に無効化

        // --- イベントリスナー ---
        restartButton.addEventListener('click', initGame);

        // --- ゲームの初期化 ---
        function initGame() {
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(EMPTY));
            board[3][3] = WHITE;
            board[3][4] = BLACK;
            board[4][3] = BLACK;
            board[4][4] = WHITE;
            
            currentPlayer = BLACK;
            gameOver = false;
            playerTurnBlocked = false;
            
            renderBoard();
            updateMessage('あなたの番です');
        }

        // --- ボードの描画 ---
        function renderBoard() {
            boardElement.innerHTML = '';
            let blackCount = 0;
            let whiteCount = 0;
            const validMoves = getValidMoves(currentPlayer);

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    const pieceValue = board[r][c];
                    if (pieceValue !== EMPTY) {
                        const piece = document.createElement('div');
                        piece.className = `piece ${pieceValue === BLACK ? 'black' : 'white'}`;
                        cell.appendChild(piece);
                        if (pieceValue === BLACK) blackCount++;
                        else whiteCount++;
                    } else if (currentPlayer === BLACK && !playerTurnBlocked) {
                        // プレイヤーの有効な手を表示
                        const isMoveValid = validMoves.some(move => move.r === r && move.c === c);
                        if (isMoveValid) {
                            const hint = document.createElement('div');
                            hint.className = 'valid-move-hint';
                            cell.appendChild(hint);
                            cell.addEventListener('click', () => handleCellClick(r, c));
                        }
                    }
                    boardElement.appendChild(cell);
                }
            }
            blackScoreElement.textContent = blackCount;
            whiteScoreElement.textContent = whiteCount;
        }

        // --- メッセージの更新 ---
        function updateMessage(text) {
            messageArea.textContent = text;
        }

        // --- セルクリック時の処理 ---
        function handleCellClick(r, c) {
            if (gameOver || currentPlayer !== BLACK || playerTurnBlocked) return;

            const validMoves = getValidMoves(BLACK);
            const isValid = validMoves.some(move => move.r === r && move.c === c);

            if (isValid) {
                makeMove(r, c, BLACK);
            }
        }

        // --- 石を置き、裏返す処理 ---
        function makeMove(r, c, player) {
            const piecesToFlip = getFlips(r, c, player);
            if (piecesToFlip.length === 0) return;

            board[r][c] = player;
            piecesToFlip.forEach(p => {
                board[p.r][p.c] = player;
            });
            
            switchTurn();
        }
        
        // --- ターンを切り替える (修正済み) ---
        async function switchTurn() {
            renderBoard(); // まず、実行された手を盤面に反映します
            currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;

            if (checkGameOver()) {
                return;
            }

            const validMoves = getValidMoves(currentPlayer);

            // 現在のプレイヤーが置ける場所がない場合、パスする
            if (validMoves.length === 0) {
                updateMessage(`${currentPlayer === BLACK ? 'あなた' : 'AI'}はパスしました`);
                await new Promise(resolve => setTimeout(resolve, 1500)); // 1.5秒待つ
                currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK; // ターンを相手に戻す
                
                // 相手も置けない場合はゲーム終了
                if (checkGameOver()) return; 
                
                const nextValidMoves = getValidMoves(currentPlayer);
                if(nextValidMoves.length === 0) {
                    checkGameOver(); // 両者パスならゲーム終了
                    return;
                }
            }

            // 次のターンの準備
            if (currentPlayer === WHITE) {
                playerTurnBlocked = true; // プレイヤーの操作をブロック
                updateMessage('AIが考えています...');
                renderBoard(); // AIの思考中にヒントが表示されないように盤面を再描画
                setTimeout(computerTurn, 500);
            } else {
                playerTurnBlocked = false; // プレイヤーの操作ブロックを解除
                updateMessage('あなたの番です');
                renderBoard(); // プレイヤーの番になったので、ヒント付きで盤面を再描画
            }
        }

        // --- コンピュータのターン ---
        function computerTurn() {
            const bestMove = findBestMove();
            if (bestMove) {
                makeMove(bestMove.r, bestMove.c, WHITE);
            }
        }

        // --- ゲームオーバーの判定 ---
        function checkGameOver() {
            const blackMoves = getValidMoves(BLACK);
            const whiteMoves = getValidMoves(WHITE);

            if (blackMoves.length === 0 && whiteMoves.length === 0) {
                gameOver = true;
                let blackCount = 0;
                let whiteCount = 0;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] === BLACK) blackCount++;
                        if (board[r][c] === WHITE) whiteCount++;
                    }
                }
                
                let message = "ゲーム終了！ ";
                if (blackCount > whiteCount) message += "あなたの勝ちです！";
                else if (whiteCount > blackCount) message += "AIの勝ちです。";
                else message += "引き分けです。";
                
                updateMessage(message);
                return true;
            }
            return false;
        }

        // --- 有効な手を取得する ---
        function getValidMoves(player) {
            const moves = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === EMPTY) {
                        const flips = getFlips(r, c, player);
                        if (flips.length > 0) {
                            moves.push({ r, c });
                        }
                    }
                }
            }
            return moves;
        }

        // --- 指定した場所に置いた場合に裏返る石のリストを取得 ---
        function getFlips(r, c, player) {
            const opponent = (player === BLACK) ? WHITE : BLACK;
            const allFlips = [];

            for (const [dr, dc] of DIRECTIONS) {
                let currentFlips = [];
                let cr = r + dr;
                let cc = c + dc;

                while (cr >= 0 && cr < BOARD_SIZE && cc >= 0 && cc < BOARD_SIZE) {
                    if (board[cr][cc] === opponent) {
                        currentFlips.push({ r: cr, c: cc });
                    } else if (board[cr][cc] === player) {
                        allFlips.push(...currentFlips);
                        break;
                    } else { // EMPTY
                        break;
                    }
                    cr += dr;
                    cc += dc;
                }
            }
            return allFlips;
        }

        // --- AIの思考ロジック ---
        function findBestMove() {
            let bestScore = -Infinity;
            let bestMove = null;
            const validMoves = getValidMoves(WHITE);

            if (validMoves.length === 0) return null;
            if (validMoves.length === 1) return validMoves[0];

            for (const move of validMoves) {
                const newBoard = JSON.parse(JSON.stringify(board)); // ボードをディープコピー
                const piecesToFlip = getFlips(move.r, move.c, WHITE);
                newBoard[move.r][move.c] = WHITE;
                piecesToFlip.forEach(p => { newBoard[p.r][p.c] = WHITE; });
                
                const score = minimax(newBoard, AI_DEPTH - 1, -Infinity, Infinity, false);
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }

        // --- ミニマックス法（アルファベータ法による枝刈り付き） ---
        function minimax(currentBoard, depth, alpha, beta, isMaximizingPlayer) {
            if (depth === 0 || isGameOver(currentBoard)) {
                return evaluateBoard(currentBoard);
            }

            const player = isMaximizingPlayer ? WHITE : BLACK;
            const validMoves = getValidMovesForBoard(currentBoard, player);

            if (validMoves.length === 0) {
                 return minimax(currentBoard, depth - 1, alpha, beta, !isMaximizingPlayer);
            }

            if (isMaximizingPlayer) { // AIのターン（最大化）
                let maxEval = -Infinity;
                for (const move of validMoves) {
                    const newBoard = createNewBoardState(currentBoard, move, player);
                    const evaluation = minimax(newBoard, depth - 1, alpha, beta, false);
                    maxEval = Math.max(maxEval, evaluation);
                    alpha = Math.max(alpha, evaluation);
                    if (beta <= alpha) {
                        break; // ベータ枝刈り
                    }
                }
                return maxEval;
            } else { // プレイヤーのターン（最小化）
                let minEval = Infinity;
                for (const move of validMoves) {
                    const newBoard = createNewBoardState(currentBoard, move, player);
                    const evaluation = minimax(newBoard, depth - 1, alpha, beta, true);
                    minEval = Math.min(minEval, evaluation);
                    beta = Math.min(beta, evaluation);
                    if (beta <= alpha) {
                        break; // アルファ枝刈り
                    }
                }
                return minEval;
            }
        }
        
        function createNewBoardState(currentBoard, move, player) {
            const newBoard = JSON.parse(JSON.stringify(currentBoard));
            const piecesToFlip = getFlipsForBoard(newBoard, move.r, move.c, player);
            newBoard[move.r][move.c] = player;
            piecesToFlip.forEach(p => { newBoard[p.r][p.c] = player; });
            return newBoard;
        }

        function isGameOver(b) {
            return getValidMovesForBoard(b, BLACK).length === 0 && getValidMovesForBoard(b, WHITE).length === 0;
        }

        // --- 盤面評価関数 ---
        function evaluateBoard(b) {
            let whiteScore = 0;
            let blackScore = 0;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (b[r][c] === WHITE) {
                        whiteScore += POSITION_WEIGHTS[r][c];
                    } else if (b[r][c] === BLACK) {
                        blackScore += POSITION_WEIGHTS[r][c];
                    }
                }
            }
            return whiteScore - blackScore;
        }

        // --- シミュレーション用のヘルパー関数 ---
        function getValidMovesForBoard(b, player) {
            const moves = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (b[r][c] === EMPTY) {
                        if (getFlipsForBoard(b, r, c, player).length > 0) {
                            moves.push({ r, c });
                        }
                    }
                }
            }
            return moves;
        }

        function getFlipsForBoard(b, r, c, player) {
            const opponent = (player === BLACK) ? WHITE : BLACK;
            const allFlips = [];
            for (const [dr, dc] of DIRECTIONS) {
                let currentFlips = [];
                let cr = r + dr;
                let cc = c + dc;
                while (cr >= 0 && cr < BOARD_SIZE && cc >= 0 && cc < BOARD_SIZE) {
                    if (b[cr][cc] === opponent) {
                        currentFlips.push({ r: cr, c: cc });
                    } else if (b[cr][cc] === player) {
                        allFlips.push(...currentFlips);
                        break;
                    } else {
                        break;
                    }
                    cr += dr;
                    cc += dc;
                }
            }
            return allFlips;
        }


        // --- ゲーム開始 ---
        window.onload = initGame;
    </script>
</body>
</html>
